/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│vi: set net ft=c ts=2 sts=2 sw=2 fenc=utf-8                                :vi│
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include "libc/calls/calls.h"
#include "libc/calls/internal.h"
#include "libc/calls/struct/fd.internal.h"
#include "libc/calls/struct/sigaction.internal.h"
#include "libc/fmt/itoa.h"
#include "libc/intrin/dll.h"
#include "libc/intrin/handlock.internal.h"
#include "libc/intrin/weaken.h"
#include "libc/nt/accounting.h"
#include "libc/nt/console.h"
#include "libc/nt/enum/startf.h"
#include "libc/nt/enum/status.h"
#include "libc/nt/enum/wait.h"
#include "libc/nt/errors.h"
#include "libc/nt/files.h"
#include "libc/nt/memory.h"
#include "libc/nt/runtime.h"
#include "libc/nt/struct/msg.h"
#include "libc/nt/struct/processinformation.h"
#include "libc/nt/struct/startupinfo.h"
#include "libc/nt/synchronization.h"
#include "libc/nt/thread.h"
#include "libc/nt/thunk/msabi.h"
#include "libc/proc/ntspawn.h"
#include "libc/proc/proc.internal.h"
#include "libc/runtime/memtrack.internal.h"
#include "libc/runtime/runtime.h"
#include "libc/sock/sock.h"
#include "libc/str/str.h"
#include "libc/sysv/consts/o.h"
#include "libc/sysv/consts/sig.h"
#include "libc/sysv/errfuns.h"
#include "libc/thread/itimer.internal.h"
#include "libc/thread/posixthread.internal.h"
#include "libc/thread/tls.h"
#ifdef __x86_64__

#define keywords textwindows dontinstrument

// clang-format off
__msabi extern typeof(CloseHandle) *const __imp_CloseHandle;
__msabi extern typeof(DuplicateHandle) *const __imp_DuplicateHandle;
__msabi extern typeof(GenerateConsoleCtrlEvent) *const __imp_GenerateConsoleCtrlEvent;
__msabi extern typeof(GetCurrentThreadId) *const __imp_GetCurrentThreadId;
__msabi extern typeof(GetExitCodeProcess) *const __imp_GetExitCodeProcess;
__msabi extern typeof(GetLastError) *const __imp_GetLastError;
__msabi extern typeof(OpenThread) *const __imp_OpenThread;
__msabi extern typeof(SetConsoleCtrlHandler) *const __imp_SetConsoleCtrlHandler;
__msabi extern typeof(SetHandleInformation) *const __imp_SetHandleInformation;
__msabi extern typeof(TerminateThread) *const __imp_TerminateThread;
__msabi extern typeof(UnmapViewOfFile) *const __imp_UnmapViewOfFile;
__msabi extern typeof(WaitForSingleObject) *const __imp_WaitForSingleObject;
// clang-format on

extern long __klog_handle;
static void sys_execve_nt_relay(intptr_t, long, long, long);
void __stack_call(intptr_t, long, long, long,
                  void (*)(intptr_t, intptr_t, long, long),
                  intptr_t) wontreturn;

static keywords void PurgeHandle(intptr_t h) {
  if (!h) return;
  if (h == -1) return;
  __imp_CloseHandle(h);
}

static keywords void PurgeThread(intptr_t h) {
  if (h && h != -1) {
    __imp_TerminateThread(h, SIGKILL);
    __imp_CloseHandle(h);
  }
}

static keywords void sys_execve_inherit(int64_t hands[3], bool32 bInherit) {
  for (int i = 0; i < 3; ++i) {
    if (hands[i] != -1) {
      __imp_SetHandleInformation(hands[i], kNtHandleFlagInherit, bInherit);
    }
  }
}

keywords int sys_execve_nt(const char *program, char *const argv[],
                           char *const envp[]) {
  size_t i;

  __hand_lock();
  pthread_spin_lock(&_pthread_lock);

  // pass bitmask telling child which fds are sockets
  int bits;
  char buf[32], *v = 0;
  if (_weaken(socket)) {
    for (bits = i = 0; i < 3; ++i) {
      if (g_fds.p[i].kind == kFdSocket) {
        bits |= 1 << i;
      }
    }
    FormatInt32(stpcpy(buf, "__STDIO_SOCKETS="), bits);
    v = buf;
  }

  // define stdio handles for the spawned subprocess
  struct NtStartupInfo si = {
      .cb = sizeof(struct NtStartupInfo),
      .dwFlags = kNtStartfUsestdhandles,
  };
  for (i = 0; i <= 2; ++i) {
    if (g_fds.p[i].kind != kFdEmpty &&  //
        !(g_fds.p[i].flags & O_CLOEXEC)) {
      si.stdiofds[i] = g_fds.p[i].handle;
    } else {
      si.stdiofds[i] = -1;
    }
  }

  // launch the process
  struct NtProcessInformation pi;
  sys_execve_inherit(si.stdiofds, true);
  int rc = ntspawn(program, argv, envp, v, 0, 0, true, 0, 0, &si, &pi);
  if (rc == -1) {
    sys_execve_inherit(si.stdiofds, false);
    __hand_unlock();
    if (__imp_GetLastError() == kNtErrorSharingViolation) {
      return etxtbsy();
    } else {
      return -1;
    }
  }
  PurgeHandle(pi.hThread);

  // kill siblings
  struct Dll *e;
  for (e = dll_first(_pthread_list); e; e = dll_next(_pthread_list, e)) {
    struct PosixThread *pt = POSIXTHREAD_CONTAINER(e);
    if ((pthread_t)pt == __get_tls()->tib_pthread) continue;
    PurgeThread(pt->tib->tib_syshand);
    PurgeHandle(pt->semaphore);
  }
  if (_weaken(__itimer)) {
    PurgeThread(_weaken(__itimer)->thread);
  }
  if (_weaken(__proc)) {
    PurgeThread(_weaken(__proc)->thread);
    PurgeHandle(_weaken(__proc)->onstart);
  }

  // retreat to original win32-provided stack memory
  __ftrace = 0;
  __stack_call(pi.hProcess, 0, 0, 0, sys_execve_nt_relay, __oldstack);
}

// child is in same process group so wait for it to get killed by this
__msabi static keywords bool32 sys_execve_nt_event(uint32_t dwCtrlType) {
  return true;  // tell win32 we handled signal
}

// this function runs on the original tiny stack that windows gave us
// we need to keep the original process alive simply to pass an int32
// so we unmap all memory to avoid getting a double whammy after fork
static keywords void sys_execve_nt_relay(intptr_t h, long b, long c, long d) {
  uint32_t i, dwExitCode;

  // close more handles
  __imp_SetConsoleCtrlHandler((void *)sys_execve_nt_event, 1);
  PurgeThread(g_fds.stdin.thread);
  PurgeHandle(g_fds.stdin.reader);
  PurgeHandle(g_fds.stdin.writer);
  for (i = 0; i < g_fds.n; ++i) {
    if (g_fds.p[i].kind != kFdEmpty) {
      PurgeHandle(g_fds.p[i].handle);
      if (g_fds.p[i].kind == kFdConsole) {
        PurgeHandle(g_fds.p[i].extra);
      }
    }
  }

  // free all the memory mmap created
  for (i = 0; i < _mmi.i; ++i) {
    __imp_UnmapViewOfFile((void *)((uintptr_t)_mmi.p[i].x << 16));
    PurgeHandle(_mmi.p[i].h);
  }

  // wait for process to terminate
  //
  // WaitForSingleObject can return kNtWaitAbandoned which MSDN
  // describes as a "sort of" successful status which indicates
  // someone else didn't free a mutex and you should check that
  // persistent resources haven't been left corrupted. not sure
  // what those resources would be for process objects, however
  // this status has actually been observed when waiting on 'em
  do {
    dwExitCode = 255;
    if (__imp_WaitForSingleObject(h, -1) != kNtWaitFailed) {
      __imp_GetExitCodeProcess(h, &dwExitCode);
    }
  } while (dwExitCode == kNtStillActive);

  // propagate child exit status to parent
  TerminateThisProcess(dwExitCode);
}

#endif /* __x86_64__ */
